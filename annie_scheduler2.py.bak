# annie_scheduler.py
import asyncio
import logging
import sys
import time
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo
import aiohttp
import os

from temporalio import activity, workflow
from temporalio.client import Client
from temporalio.worker import Worker
from temporalio.common import RetryPolicy

# ====== CONFIG ======
BASE_URL = os.getenv("ANNIE_BASE_URL", "https://134210b168e4.ngrok-free.app")
TASK_QUEUE = os.getenv("ANNIE_TASK_QUEUE", "annie-task-queue")
TEMPORAL_ENDPOINT = os.getenv("TEMPORAL_ENDPOINT", "localhost:7233")

# Defaults for org scheduler (edit or override via CLI)
SCHEDULE_DEFAULT_ORG_ID = 6
SCHEDULE_DEFAULT_HOUR_EST = 7
SCHEDULE_DEFAULT_MINUTE_EST = 7

CALL_POLL_INTERVAL = 10
CALL_POLL_ATTEMPTS = 12
RETRY_DELAY_SECONDS = 4 * 60
MAX_DAILY_RETRIES = 3

# ====== Logging ======
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)s %(name)s: %(message)s",
    stream=sys.stdout,
)
logger = logging.getLogger("annie_scheduler")

# ====== Client-only helpers (safe to call outside workflows) ======
def utc_date_for_est_today() -> str:
    """
    Client-side helper: Return today's date in US/Eastern, expressed as UTC YYYY-MM-DD string.
    NOTE: Do NOT call this from inside a workflow (it's non-deterministic).
    """
    est = ZoneInfo("US/Eastern")
    now_est = datetime.now(est)
    now_utc = now_est.astimezone(ZoneInfo("UTC"))
    return now_utc.date().isoformat()

def est_time_to_utc_cron(hour: int, minute: int, tz_name: str = "US/Eastern") -> str:
    """
    Convert a daily time in tz_name to a 5-field UTC cron string using today's offset.
    Returns e.g. "30 13 * * *" (minute hour ...).
    """
    today = datetime.now(ZoneInfo(tz_name))
    local = today.replace(hour=hour, minute=minute, second=0, microsecond=0)
    utc_dt = local.astimezone(ZoneInfo("UTC"))
    return f"{utc_dt.minute} {utc_dt.hour} * * *"

# ====== Activities ======
@activity.defn
async def start_call(*args, **kwargs) -> str:
    """
    Robust start_call activity. Flexible args/kwargs.
    Returns call_id as string.
    """
    patient_id = None
    workflow_id = None
    org_id = None
    to_number = None
    agent = "annie_RPM"
    test_mode = False

    if len(args) >= 1:
        patient_id = args[0]
    if len(args) >= 2:
        workflow_id = args[1]
    if len(args) >= 3:
        org_id = args[2]
    if len(args) >= 4:
        to_number = args[3]
    if len(args) >= 5:
        agent = args[4]
    if len(args) >= 6:
        test_mode = args[5]

    # override from kwargs
    patient_id = kwargs.get("patient_id", patient_id)
    workflow_id = kwargs.get("workflow_id", workflow_id)
    org_id = kwargs.get("org_id", org_id)
    to_number = kwargs.get("to_number", to_number)
    agent = kwargs.get("agent", agent)
    test_mode = kwargs.get("test_mode", test_mode)

    if patient_id is None or workflow_id is None:
        logger.error("start_call missing required patient_id or workflow_id: args=%s kwargs=%s", args, kwargs)
        raise RuntimeError("start_call requires patient_id and workflow_id")

    if test_mode:
        fake_id = f"fake-call-{int(time.time())}"
        logger.info("Activity[start_call] test_mode -> %s", fake_id)
        return fake_id

    # coerce org_id
    if org_id is not None:
        try:
            org_id = int(org_id)
        except Exception:
            logger.warning("start_call: invalid org_id provided: %s", org_id)

    # resolve phone if not provided
    if not to_number:
        logger.info("Activity[start_call] fetching patient %s to resolve phone", patient_id)
        async with aiohttp.ClientSession() as s:
            resp = await s.get(f"{BASE_URL}/api/patients/{patient_id}", timeout=30)
            text = await resp.text()
            if resp.status == 404:
                logger.error("Activity[start_call] patient not found %s", patient_id)
                raise RuntimeError(f"patient not found: {patient_id}")
            if resp.status >= 400:
                logger.error("Activity[start_call] GET /api/patients/%s returned %s body=%s", patient_id, resp.status, text)
                raise RuntimeError(f"failed to fetch patient {patient_id}: {text}")
            try:
                patient = await resp.json()
            except Exception:
                logger.error("Activity[start_call] patient endpoint returned non-json: %s", text)
                raise RuntimeError(f"patient endpoint non-json: {text}")

            to_number = (
                patient.get("to_number")
                or patient.get("phone")
                or patient.get("mobile")
                or patient.get("contact")
                or patient.get("phone_number")
            )
            if not to_number:
                logger.error("Activity[start_call] patient record missing phone: %s", patient)
                raise RuntimeError(f"patient {patient_id} missing phone")

    payload = {
        "org_id": org_id,
        "patient_id": int(patient_id),
        "to_number": to_number,
        "agent": agent,
    }
    if payload["org_id"] is None:
        payload.pop("org_id")

    url = f"{BASE_URL}/api/calls/outbound"
    logger.info("Activity[start_call] POST %s payload=%s", url, payload)

    async with aiohttp.ClientSession() as s:
        resp = await s.post(url, json=payload, timeout=60)
        text = await resp.text()
        if resp.status >= 400:
            try:
                err = await resp.json()
            except Exception:
                err = text
            logger.error("Activity[start_call] backend error status=%s body=%s", resp.status, err)
            raise RuntimeError(f"start_call failed: status={resp.status} body={err}")

        try:
            js = await resp.json()
        except Exception:
            logger.error("Activity[start_call] response not JSON: %s", text)
            raise RuntimeError(f"start_call got non-json response: {text}")

        call_id = js.get("call_id") or js.get("CallSid") or js.get("id")
        if call_id is None:
            logger.error("Activity[start_call] missing call_id in response: %s", js)
            raise RuntimeError(f"start_call response missing call_id: {js}")

        # ensure string
        call_id = str(call_id)
        logger.info("Activity[start_call] success call_id=%s", call_id)
        return call_id

@activity.defn
async def get_est_today_date() -> str:
    """
    Activity: compute the UTC date string (YYYY-MM-DD) corresponding to *today in US/Eastern*.
    This runs outside the workflow sandbox (non-deterministic code allowed).
    """
    est = ZoneInfo("US/Eastern")
    now_est = datetime.now(est)
    now_utc = now_est.astimezone(ZoneInfo("UTC"))
    return now_utc.date().isoformat()

@activity.defn
async def get_call_details(call_id: str) -> dict:
    logger.info("Activity[get_call_details] %s", call_id)
    async with aiohttp.ClientSession() as s:
        resp = await s.get(f"{BASE_URL}/api/calls/{call_id}", timeout=30)
        if resp.status == 404:
            return {}
        resp.raise_for_status()
        return await resp.json()

@activity.defn
async def list_calls_for_org_on_date(org_id: int, yyyy_mm_dd: str) -> list:
    logger.info("Activity[list_calls_for_org_on_date] org=%s date=%s", org_id, yyyy_mm_dd)
    url = f"{BASE_URL}/api/calls/"  # trailing slash avoids 307 redirect
    params = {"org_id": org_id, "date": yyyy_mm_dd}
    headers = {}
    auth_header = os.getenv("ANNIE_API_AUTH_HEADER")
    if auth_header:
        headers["Authorization"] = auth_header

    async with aiohttp.ClientSession() as s:
        resp = await s.get(url, params=params, timeout=30, allow_redirects=True, headers=headers)
        text = await resp.text()
        if resp.status >= 400:
            logger.error("Activity[list_calls_for_org_on_date] GET %s returned %s body=%s", resp.url, resp.status, text)
            resp.raise_for_status()
        try:
            js = await resp.json()
        except Exception:
            logger.error("Activity[list_calls_for_org_on_date] response not JSON: %s", text)
            return []
        logger.debug("Activity[list_calls_for_org_on_date] got %d records", len(js) if isinstance(js, list) else 0)
        return js

@activity.defn
async def fetch_call_readings(call_id: str) -> list:
    logger.info("Activity[fetch_call_readings] %s", call_id)
    async with aiohttp.ClientSession() as s:
        resp = await s.get(f"{BASE_URL}/api/calls/{call_id}/readings", timeout=30)
        if resp.status == 404:
            return []
        resp.raise_for_status()
        return await resp.json()

@activity.defn
async def mark_call_completed(call_id: str, summary: dict):
    logger.info("Activity[mark_call_completed] %s %s", call_id, summary)
    async with aiohttp.ClientSession() as s:
        await s.post(f"{BASE_URL}/api/calls/{call_id}/complete", json=summary, timeout=30)

@activity.defn
async def list_patients_for_org(org_id: int) -> list:
    logger.info("Activity[list_patients_for_org] org=%s", org_id)
    async with aiohttp.ClientSession() as s:
        resp = await s.get(f"{BASE_URL}/api/patients", params={"org_id": org_id, "page": 1, "limit": 1000}, timeout=60)
        resp.raise_for_status()
        return await resp.json()

# ====== Workflows ======
@workflow.defn
class OrgDailyScheduler:
    @workflow.run
    async def run(self, org_id: int, test_mode: bool = False):
        logger.info("OrgDailyScheduler started for org=%s test_mode=%s", org_id, test_mode)
        patients = await workflow.execute_activity(
            list_patients_for_org,
            args=[org_id],
            start_to_close_timeout=timedelta(seconds=60),
            retry_policy=RetryPolicy(initial_interval=timedelta(seconds=1), maximum_attempts=3),
        )
        for p in patients:
            pid = p.get("id")
            if not pid:
                continue
            try:
                await workflow.start_child_workflow(
                    PatientDailyCall.run,
                    args=[pid, org_id, None, "annie_RPM", test_mode],
                    task_queue=TASK_QUEUE,
                )
                logger.info("OrgDailyScheduler started PatientDailyCall for patient=%s", pid)
            except Exception as e:
                logger.warning("Failed to start child workflow for patient %s: %s", pid, e)

@workflow.defn
class PatientDailyCall:
    def __init__(self):
        self._latest_call_signal = None
        self._call_signal_set = False

    @workflow.signal
    def call_status_signal(self, call_id: str, status: str):
        self._latest_call_signal = {"call_id": call_id, "status": status}
        self._call_signal_set = True

    @workflow.run
    async def run(
        self,
        patient_id: int,
        org_id: int = None,
        to_number: str = None,
        agent: str = "annie_RPM",
        test_mode: bool = False,
    ):
        logger.info("Workflow started for patient=%s org=%s", patient_id, org_id)
        retries = 0
        last_call_id = None

        while retries < MAX_DAILY_RETRIES:
            retries += 1
            wf_id = workflow.info().workflow_id
            logger.info("Workflow attempt=%d wf_id=%s", retries, wf_id)

            last_call_id = await workflow.execute_activity(
                start_call,
                args=[patient_id, wf_id, org_id, to_number, agent, test_mode],
                start_to_close_timeout=timedelta(seconds=60),
                retry_policy=RetryPolicy(initial_interval=timedelta(seconds=1), maximum_attempts=1),
            )

            self._call_signal_set = False
            self._latest_call_signal = None

            status = None
            try:
                await workflow.wait_condition(
                    lambda: getattr(self, "_call_signal_set", False),
                    timeout=timedelta(seconds=CALL_POLL_INTERVAL * CALL_POLL_ATTEMPTS),
                )
                sig = self._latest_call_signal
                if sig and sig.get("call_id") == last_call_id:
                    status = sig.get("status")
            except Exception:
                pass

            if status is None:
                for _ in range(CALL_POLL_ATTEMPTS):
                    details = await workflow.execute_activity(
                        get_call_details,
                        args=[last_call_id],
                        start_to_close_timeout=timedelta(seconds=15),
                        retry_policy=RetryPolicy(initial_interval=timedelta(seconds=1), maximum_attempts=2),
                    )
                    status = details.get("status")
                    if status in ("completed", "in_progress", "initiated"):
                        break
                    await workflow.sleep(timedelta(seconds=CALL_POLL_INTERVAL))

            logger.info("Workflow call_id=%s status=%s", last_call_id, status)

            if status == "completed":
                readings = await workflow.execute_activity(
                    fetch_call_readings,
                    args=[last_call_id],
                    start_to_close_timeout=timedelta(seconds=30),
                    retry_policy=RetryPolicy(initial_interval=timedelta(seconds=1), maximum_attempts=2),
                )
                await workflow.execute_activity(
                    mark_call_completed,
                    args=[last_call_id, {"result": "ok", "readings_count": len(readings) if readings else 0}],
                    start_to_close_timeout=timedelta(seconds=20),
                )
                logger.info("Workflow finished ok for call=%s", last_call_id)
                return {"result": "ok", "call_id": last_call_id, "readings": readings}

            # --- Improved retry-check ---
            should_retry = False
            if org_id is not None:
                # get the date string via activity (workflow-safe)
                today_est = await workflow.execute_activity(
                    get_est_today_date,
                    args=[],
                    start_to_close_timeout=timedelta(seconds=15),
                    retry_policy=RetryPolicy(initial_interval=timedelta(seconds=1), maximum_attempts=2),
                )
                logger.info("Checking today's calls for org=%s date=%s patient=%s", org_id, today_est, patient_id)
                calls = await workflow.execute_activity(
                    list_calls_for_org_on_date,
                    args=[org_id, today_est],
                    start_to_close_timeout=timedelta(seconds=20),
                    retry_policy=RetryPolicy(initial_interval=timedelta(seconds=1), maximum_attempts=2),
                )

                logger.info("list_calls_for_org_on_date returned %d records", len(calls) if calls else 0)
                logger.debug("Calls payload: %s", calls)

                for c in calls or []:
                    status = c.get("status")
                    if status is None:
                        status = c.get("call_status") or c.get("state")
                    status_norm = str(status).lower() if status is not None else None

                    candidate_vals = []
                    for k in ("patient_db_id", "patient_id", "patientId", "patient", "id"):
                        if k in c:
                            candidate_vals.append((k, c.get(k)))
                    if "patient" in c and isinstance(c["patient"], dict):
                        for kk in ("id", "patient_id"):
                            if kk in c["patient"]:
                                candidate_vals.append(("patient." + kk, c["patient"].get(kk)))

                    matched = False
                    for key, val in candidate_vals:
                        if val is None:
                            continue
                        try:
                            if int(val) == int(patient_id):
                                matched = True
                                logger.info("Matched patient via field %s value=%s", key, val)
                                break
                        except Exception:
                            if str(val) == str(patient_id):
                                matched = True
                                logger.info("Matched patient via field %s value=%s (string match)", key, val)
                                break

                    if not matched:
                        logger.debug("Call record %s did not match patient %s (candidate fields=%s)", c.get("id") or c, patient_id, candidate_vals)
                        continue

                    if status_norm is None:
                        logger.info("Call matched for patient=%s but status missing, treating as open => retry", patient_id)
                        should_retry = True
                        break

                    if status_norm != "completed":
                        logger.info("Call matched for patient=%s with status=%s -> will retry", patient_id, status_norm)
                        should_retry = True
                        break
                    else:
                        logger.info("Call matched for patient=%s with status completed -> no retry", patient_id)
                        should_retry = False
                        break
            else:
                should_retry = True

            if should_retry and retries < MAX_DAILY_RETRIES:
                logger.info("Workflow will retry after %d seconds (attempt %d/%d)", RETRY_DELAY_SECONDS, retries, MAX_DAILY_RETRIES)
                logger.info("Sleeping before retry...")
                await workflow.sleep(timedelta(seconds=RETRY_DELAY_SECONDS))
                continue

            await workflow.execute_activity(
                mark_call_completed,
                args=[last_call_id, {"result": "not_completed", "status": status}],
                start_to_close_timeout=timedelta(seconds=20),
            )
            logger.info("Workflow finished not_completed call=%s status=%s", last_call_id, status)
            return {"result": "not_completed", "call_id": last_call_id, "status": status}

        await workflow.execute_activity(
            mark_call_completed,
            args=[last_call_id, {"result": "max_retries_exhausted"}],
            start_to_close_timeout=timedelta(seconds=20),
        )
        logger.info("Workflow exhausted retries for call=%s", last_call_id)
        return {"result": "max_retries_exhausted", "call_id": last_call_id}

# ====== Client connect w/ retry ======
async def connect_client(retries: int = 6, delay: int = 5) -> Client:
    for i in range(retries):
        try:
            client = await Client.connect(TEMPORAL_ENDPOINT)
            logger.info("Connected to Temporal at %s", TEMPORAL_ENDPOINT)
            return client
        except Exception as e:
            logger.warning("Temporal connect failed (%d/%d): %s", i + 1, retries, e)
            await asyncio.sleep(delay)
    logger.error("Could not connect to Temporal at %s after %d attempts", TEMPORAL_ENDPOINT, retries)
    raise RuntimeError("Temporal connect failed")

# ====== Worker runner ======
async def run_worker():
    client = await connect_client()
    logger.info("Starting worker for task_queue=%s", TASK_QUEUE)
    worker = Worker(
        client,
        task_queue=TASK_QUEUE,
        workflows=[PatientDailyCall, OrgDailyScheduler],
        activities=[
            start_call,
            get_est_today_date,
            get_call_details,
            list_calls_for_org_on_date,
            fetch_call_readings,
            mark_call_completed,
            list_patients_for_org,
        ],
    )
    logger.info("Worker created - now running (this call blocks until worker stops).")
    await worker.run()
    logger.info("Worker.run() returned (worker stopped).")

# ====== Small helper to start a test workflow ======
async def start_test_workflow(patient_id: int = 2, org_id: int = 1, wait: bool = False):
    client = await connect_client()
    wf_id = f"test-wf-{int(time.time())}"
    handle = await client.start_workflow(
        PatientDailyCall.run,
        id=wf_id,
        task_queue=TASK_QUEUE,
        args=[patient_id, org_id, None, "annie_RPM", False],
    )
    logger.info("Started test workflow id=%s, run_id=%s", handle.id, handle.run_id)
    if wait:
        result = await handle.result()
        logger.info("Workflow result: %s", result)
        return result
    return handle

# ====== Create org scheduler helper (client-side) ======
async def create_org_scheduler(org_id: int = SCHEDULE_DEFAULT_ORG_ID, hour_est: int = SCHEDULE_DEFAULT_HOUR_EST, minute_est: int = SCHEDULE_DEFAULT_MINUTE_EST, test_mode: bool = False):
    client = await connect_client()
    cron = est_time_to_utc_cron(hour_est, minute_est, tz_name="US/Eastern")
    wf_id = f"org-scheduler-{org_id}"
    handle = await client.start_workflow(
        OrgDailyScheduler.run,
        args=[org_id, test_mode],
        id=wf_id,
        task_queue=TASK_QUEUE,
        cron_schedule=cron,
    )
    logger.info("Started org scheduler workflow id=%s cron=%s", handle.id, cron)
    return handle

# ====== CLI ======
if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "test":
        wait = "--wait" in sys.argv
        default_pid = int(os.getenv("TEST_PATIENT_ID", "2"))
        default_oid = int(os.getenv("TEST_ORG_ID", "1"))
        pid = default_pid
        oid = default_oid

        if "--patient" in sys.argv:
            try:
                pid = int(sys.argv[sys.argv.index("--patient") + 1])
            except Exception:
                print("Invalid --patient value; must be integer")
                sys.exit(1)
        if "--org" in sys.argv:
            try:
                oid = int(sys.argv[sys.argv.index("--org") + 1])
            except Exception:
                print("Invalid --org value; must be integer")
                sys.exit(1)

        async def run_test():
            return await start_test_workflow(pid, oid, wait)

        try:
            res = asyncio.run(run_test())
            if wait:
                print("Workflow completed:", res)
            else:
                print("Test workflow started. Check worker logs or Temporal UI.")
        except Exception:
            logger.exception("Failed to start test workflow")
            sys.exit(1)
        sys.exit(0)

    if len(sys.argv) > 1 and sys.argv[1] == "create_scheduler":
        org_id = SCHEDULE_DEFAULT_ORG_ID
        hour = SCHEDULE_DEFAULT_HOUR_EST
        minute = SCHEDULE_DEFAULT_MINUTE_EST
        test_mode_flag = False

        if "--org" in sys.argv:
            try:
                org_id = int(sys.argv[sys.argv.index("--org") + 1])
            except Exception:
                print("Invalid --org value; must be integer")
                sys.exit(1)
        if "--hour" in sys.argv:
            try:
                hour = int(sys.argv[sys.argv.index("--hour") + 1])
            except Exception:
                print("Invalid --hour value; must be integer 0-23")
                sys.exit(1)
        if "--minute" in sys.argv:
            try:
                minute = int(sys.argv[sys.argv.index("--minute") + 1])
            except Exception:
                print("Invalid --minute value; must be integer 0-59")
                sys.exit(1)
        if "--test" in sys.argv:
            test_mode_flag = True

        async def run_create():
            return await create_org_scheduler(org_id=org_id, hour_est=hour, minute_est=minute, test_mode=test_mode_flag)

        try:
            h = asyncio.run(run_create())
            print(f"Org scheduler started: id={h.id} cron (UTC)={est_time_to_utc_cron(hour, minute)}")
        except Exception:
            logger.exception("Failed to create org scheduler")
            sys.exit(1)
        sys.exit(0)

    try:
        asyncio.run(run_worker())
    except KeyboardInterrupt:
        logger.info("Worker interrupted by user, exiting.")
    except Exception:
        logger.exception("Worker failed")
        raise
